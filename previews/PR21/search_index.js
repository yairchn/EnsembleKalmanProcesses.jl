var documenterSearchIndex = {"docs":
[{"location":"observations/#Observations","page":"Observations","title":"Observations","text":"","category":"section"},{"location":"observations/","page":"Observations","title":"Observations","text":"The Observations object is used to store the truth for convenience of the user. The ingredients are","category":"page"},{"location":"observations/","page":"Observations","title":"Observations","text":"Samples of the data Vector{Vector{Float}} or Array{Float,2}. If provided as a 2D array, the samples must be provided as columns. They are stored internally as Vector{Vector{Float}}\nAn optional covariance matrix can be provided.\nThe names of the data in this object as a String or Vector{String}","category":"page"},{"location":"observations/","page":"Observations","title":"Observations","text":"The empirical mean is calculated automatically. If a covariance matrix is not provided, then the empirical covariance is also calculated automatically.","category":"page"},{"location":"observations/#A-simple-example:","page":"Observations","title":"A simple example:","text":"","category":"section"},{"location":"observations/","page":"Observations","title":"Observations","text":"Here is a typical construction of the object","category":"page"},{"location":"observations/","page":"Observations","title":"Observations","text":"μ = zeros(5)\nΓy = rand(5,5)\nΓy = Γy'*Γy\nyt = rand(MvNormal(μ, Γy), 100) # generate 100 samples\nname = \"zero-mean mvnormal\"\n\ntrue_data = Observations.Obs(yt, Γy, name)","category":"page"},{"location":"observations/","page":"Observations","title":"Observations","text":"Currently, the data is retrieved by accessing the stored variables e.g the fifth data sample is given by truth_data.samples[5],or the covariance matrix by truth_data.cov.","category":"page"},{"location":"API/Observations/#Observations","page":"Observations","title":"Observations","text":"","category":"section"},{"location":"API/Observations/","page":"Observations","title":"Observations","text":"CurrentModule = EnsembleKalmanProcesses.Observations","category":"page"},{"location":"API/Observations/","page":"Observations","title":"Observations","text":"Obs","category":"page"},{"location":"API/Observations/#EnsembleKalmanProcesses.Observations.Obs","page":"Observations","title":"EnsembleKalmanProcesses.Observations.Obs","text":"Obs{FT<:AbstractFloat}\n\nStructure that contains the observations\n\nFields\n\nsamples\nvector of observational samples, each of length sample_dim\nobs_noise_cov\ncovariance of the observational noise (assumed to be normally     distributed); sampledim x sampledim (where sampledim is the number of     elements in each sample), or a scalar if the sample dim is 1. If not     supplied, obsnoisecov is set to a diagonal matrix whose non-zero elements     are the variances of the samples, or to a scalar variance in the case of     1d samples. obsnoise_cov is set to nothing if only a single sample is     provided.\nmean\nsample mean\ndata_names\nnames of the data\n\n\n\n\n\n","category":"type"},{"location":"installation_instructions/#Installation","page":"Installation instructions","title":"Installation","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"To build the top-level project, first clone the repository, then instantiate:","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"cd CalibrateEmulateSample.jl\njulia --project -e 'using Pkg; Pkg.instantiate()","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"To test that the package is working:","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"> julia --project -e 'using Pkg; Pkg.test()'","category":"page"},{"location":"installation_instructions/#Building-the-documentation-locally","page":"Installation instructions","title":"Building the documentation locally","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"Once the project is built, you can build the project documentation under the docs/ sub-project:","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"julia --project=docs/ -e 'using Pkg; Pkg.instantiate()'\njulia --project=docs/ docs/make.jl","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"The locally rendered HTML documentation can be viewed at docs/build/index.html","category":"page"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcessModule","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcessModule","text":"","category":"section"},{"location":"API/EnsembleKalmanProcessModule/","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcessModule","text":"CurrentModule = EnsembleKalmanProcesses.EnsembleKalmanProcessModule","category":"page"},{"location":"API/EnsembleKalmanProcessModule/","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcessModule","text":"Inversion\nSampler\nEnsembleKalmanProcess\nget_u\nget_g\nget_u_final\nget_N_iterations\nconstruct_initial_ensemble\nfind_ekp_stepsize\nupdate_ensemble!","category":"page"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.Inversion","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.Inversion","text":"Inversion <: Process\n\nAn ensemble Kalman Inversion process\n\n\n\n\n\n","category":"type"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.Sampler","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.Sampler","text":"Sampler{FT<:AbstractFloat,IT<:Int} <: Process\n\nAn ensemble Kalman Sampler process\n\n\n\n\n\n","category":"type"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.EnsembleKalmanProcess","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.EnsembleKalmanProcess","text":"EnsembleKalmanProcess{FT<:AbstractFloat, IT<:Int}\n\nStructure that is used in Ensemble Kalman processes\n\n#Fields\n\nu\nArray of stores for parameters (u), each of size [parameterdim × Nens]\nobs_mean\nvector of the observed vector size [data_dim]\nobs_noise_cov\ncovariance matrix of the observational noise, of size [datadim × datadim]\nN_ens\nensemble size\ng\nArray of stores for forward model outputs, each of size  [datadim × Nens]\nerr\nvector of errors\nΔt\nvector of timesteps used in each EK iteration\nprocess\nthe particular EK process (Inversion or Sampler)\n\n\n\n\n\n","category":"type"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.get_u","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.get_u","text":"get_u(ekp::EnsembleKalmanProcess, iteration::IT; return_array=true) where {IT <: Integer}\n\nGet for the EKI iteration. Returns a DataContainer object unless array is specified.\n\n\n\n\n\nget_u(ekp::EnsembleKalmanProcess; return_array=true)\n\nGet for the EKI iteration. Returns a DataContainer object unless array is specified.\n\n\n\n\n\n","category":"function"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.get_g","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.get_g","text":"get_g(ekp::EnsembleKalmanProcess, iteration::IT; return_array=true) where {IT <: Integer}\n\nGet for the EKI iteration. Returns a DataContainer object unless array is specified.\n\n\n\n\n\nget_g(ekp::EnsembleKalmanProcess; return_array=true)\n\nGet for the EKI iteration. Returns a DataContainer object unless array is specified.\n\n\n\n\n\n","category":"function"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.get_u_final","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.get_u_final","text":"get_u_final(ekp::EnsembleKalmanProcess, return_array=true)\n\nGet the final or prior iteration of parameters or model ouputs, returns a DataContainer Object if return_array is false.\n\n\n\n\n\n","category":"function"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.get_N_iterations","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.get_N_iterations","text":"get_N_iterations(ekp::EnsembleKalmanProcess\n\nget number of times update has been called (equals size(g), or size(u)-1) \n\n\n\n\n\n","category":"function"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.construct_initial_ensemble","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.construct_initial_ensemble","text":"construct_initial_ensemble(prior::ParameterDistribution, N_ens::IT; rng_seed=42) where {IT<:Int}\n\nConstruct the initial parameters, by sampling N_ens samples from specified prior distribution. Returned with parameters as columns\n\n\n\n\n\n","category":"function"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.find_ekp_stepsize","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.find_ekp_stepsize","text":"findekpstepsize(ekp::EnsembleKalmanProcess{FT, IT, Inversion}, g::Array{FT, 2}; cov_threshold::FT=0.01) where {FT}\n\nFind largest stepsize for the EK solver that leads to a reduction of the determinant of the sample covariance matrix no greater than cov_threshold. \n\n\n\n\n\n","category":"function"},{"location":"API/EnsembleKalmanProcessModule/#EnsembleKalmanProcesses.EnsembleKalmanProcessModule.update_ensemble!","page":"EnsembleKalmanProcessModule","title":"EnsembleKalmanProcesses.EnsembleKalmanProcessModule.update_ensemble!","text":"update_ensemble!(ekp::EnsembleKalmanProcess{FT, IT, <:Process}, g_in::Array{FT,2} cov_threshold::FT=0.01, Δt_new=nothing) where {FT, IT}\n\nUpdates the ensemble according to which type of Process we have. Model outputs gin need to be a outputdim × n_samples array (i.e data are columms)\n\n\n\n\n\n","category":"function"},{"location":"parameter_distributions/#Prior-distributions","page":"Prior distributions","title":"Prior distributions","text":"","category":"section"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"We provide a flexible setup for storing prior distribution with the ParameterDistributionStorage module found in src/ParameterDistribution.jl ","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"One can create a full parameter distribution using three inputs.","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"A Distribution, given as a ParameterDistributionType object\nAn array of Constraints, given as a Array{ConstraintType} object\nA Name, given as a String ","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"One can also provide arrays of the triple (1.,2.,3.) to create more complex distributions","category":"page"},{"location":"parameter_distributions/#A-simple-example:","page":"Prior distributions","title":"A simple example:","text":"","category":"section"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"Task: We wish to create a prior for a one-dimensional parameter. Our problem dictates that this parameter is bounded between 0 and 1. Prior knowledge dictates it is around 0.7. The parameter is called \"point_seven\".","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"Solution: We should use a Normal distribution with the predefined \"bounded\" constraint.","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"Let's initialize the constraint first,","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"constraint = [bounded(0,1)] # Sets up a logit-transformation into [0,1].","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"The prior is around 0.7, and the push forward of a normal distribution N(mean=1,sd=0.5) gives a prior with 95% of it's mass between [0.5,0.88].","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"distribution = Parameterized(Normal(1,0.5)) ","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"Finally we attach the name","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"name = \"point_seven\"","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"And the distribution is created by calling:","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"prior = ParameterDistribution(distribution,constraint,name)","category":"page"},{"location":"parameter_distributions/#.-The-ParameterDistributionType","page":"Prior distributions","title":"1. The ParameterDistributionType","text":"","category":"section"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"The ParameterDistributionType has 2 flavours for building a distribution.","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"The Parameterized type is initialized using a Julia Distributions.jl object. Samples are drawn randomly from the distribution object\nThe Samples type is initialized using a two dimensional array. Samples are drawn randomly (with replacement) from the columns of the provided array","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"One can use combinations of these distributions to construct a full parameter distribution.","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"note: Note\nWe recommend these distributions be unbounded (see about constraints below), as our methods do not preserve constraints directly.","category":"page"},{"location":"parameter_distributions/#.-The-ConstraintType","page":"Prior distributions","title":"2. The ConstraintType","text":"","category":"section"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"Our implemented algorithms do not work in constrained parameter space directly. Therefore, constraints are tackled by the mappings transform_constrained_to_unconstrained and transform_unconstrained_to_constrained. The mappings are built from either predefined or user-defined constraint functions held in the ConstraintType. ","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"In this section we call parameters are one-dimensional. Every parameter must have an associated independent ConstraintType, therefore we for each ParameterDistributionType of dimension p the user must provide a p-dimensional Array{ConstraintType}.","category":"page"},{"location":"parameter_distributions/#Predefined-ConstraintTypes","page":"Prior distributions","title":"Predefined ConstraintTypes","text":"","category":"section"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"We provide some ConstraintTypes, which apply different transformations internally to enforce bounds on physical parameter spaces. The types have the following constructors","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"no_constraint(), no transform is required for this parameter\nbounded_below(lower_bound), the physical parameter has a (provided) lower bound\nbounded_above(upper_bound), the physical parameter has a (provided) upper bound \nbounded(lower_bound,upper_bound), the physical parameter has the (provided) bounds","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"Users can also define their own transformations by directly creating a ConstraintType object with their own mappings.","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"note: Note\nIt is up to the user to ensure their provided transforms are inverses of each other.","category":"page"},{"location":"parameter_distributions/#.-The-name","page":"Prior distributions","title":"3. The name","text":"","category":"section"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"This is simply an identifier for the parameters later on.","category":"page"},{"location":"parameter_distributions/#A-more-involved-example:","page":"Prior distributions","title":"A more involved example:","text":"","category":"section"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"We create a 6-dimensional parameter distribution from 2 triples.","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"The first triple is a 4-dimensional distribution with the following constraints on parameters in physical space:","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"c1 = [no_constraint(), # no constraints\n      bounded_below(-1.0), # provide lower bound\n      bounded_above(0.4), # provide upper bound\n      bounded(-0.1,0.2)] # provide lower and upper bound","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"We choose to use a multivariate normal to represent its distribution in the transformed (unbounded) space. Here we take a tridiagonal covariance matrix.","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"diag_val = 0.5*ones(4)\nudiag_val = 0.25*ones(3)\nmean = ones(4)\ncovariance = SymTridiagonal(diagonal_val, udiag_val)\nd1 = Parameterized(MvNormal(mean,covariance)) # 4D multivariate normal","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"We also provide a name","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"name1 = \"constrained_mvnormal\"","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"The second triple is a 2-dimensional one. It is only given by 4 samples in the transformed space - (where one will typically generate samples). It is bounded in the first dimension by the constraint shown, there is a user provided transform for the second dimension - using the default constructor.","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"d2 = Samples([1.0 3.0; 5.0 7.0; 9.0 11.0; 13.0 15.0]) # 4 samples of 2D parameter space\ntransform = (x -> 3*x + 14)\ninverse_transform = (x -> (x-14) / 3)\nc2 = [bounded(10,15),\n      Constraint(transform, inverse_transform)]\nname2 = \"constrained_sampled\"","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"The full prior distribution for this setting is created with arrays of our two triples","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"u = ParameterDistribution([d1,d2],[c1,c2],[name1,name2])","category":"page"},{"location":"parameter_distributions/#Other-functions","page":"Prior distributions","title":"Other functions","text":"","category":"section"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"These functions typically return a Dict with ParameterDistribution.name as a keys, or an Array if requested ","category":"page"},{"location":"parameter_distributions/","page":"Prior distributions","title":"Prior distributions","text":"get_name: returns the names\nget_distribution: returns the Julia Distribution object if it is Parameterized\nsample_distribution: samples the Julia Distribution if Parameterized, or draws from the list of samples if Samples\ntransform_unconstrained_to_constrained: Apply the constraint mappings\ntransform_constrained_to_unconstrained: Apply the inverse constraint mappings ","category":"page"},{"location":"examples/template_example/#Template-example","page":"Template example","title":"Template example","text":"","category":"section"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"We provide the following template for how the tools may be applied.","category":"page"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"For small examples typically have 2 files.","category":"page"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"GModel.jl Contains the forward map. The inputs should be the so-called free parameters we are interested in learning, and the output should be the measured data\nThe example script which contains the inverse problem setup and solve","category":"page"},{"location":"examples/template_example/#The-structure-of-the-example-script","page":"Template example","title":"The structure of the example script","text":"","category":"section"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"First we create the data and the setting for the model","category":"page"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"Set up the forward model.\nConstruct/load the truth data. Store this data conveniently in the Observations.Obs object","category":"page"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"Then we set up the inverse problem","category":"page"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"Define the prior distributions. Use the ParameterDistribution object\nDecide on which process tool you would like to use (we recommend you begin with Invesion()). Then initialize this with the relevant constructor\ninitialize the EnsembleKalmanProcess object","category":"page"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"Then we solve the inverse problem, in a loop perform the following for as many iterations as required:","category":"page"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"Obtain the current parameter ensemble\nTransform them from the unbounded computational space to the physical space\ncall the forward map on the ensemble of parameters, producing an ensemble of measured data\ncall the update_ensemble! function to generate a new parameter ensemble based on the new data","category":"page"},{"location":"examples/template_example/","page":"Template example","title":"Template example","text":"One can then obtain the solution, dependent on the process type.","category":"page"},{"location":"ensemble_kalman_inversion/#Ensemble-Kalman-Inversion","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"","category":"section"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"One of the ensemble Kalman processes implemented in EnsembleKalmanProcesses.jl is the ensemble Kalman inversion (Iglesias et al, 2013). The ensemble Kalman inversion (EKI) is a derivative-free ensemble optimization method that seeks to find the optimal parameters theta in mathbbR^p in the inverse problem","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"\\[ y = \\mathcal{G}(\\theta) + \\eta, \\]","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"where mathcalG denotes the forward map, y in mathbbR^d is the vector of observations and eta sim mathcalN(0 Gamma_y) is additive Gaussian observational noise. Note that p is the size of the parameter vector theta and d is taken to be the size of the observation vector y. The EKI update equation for parameter vector theta^(j) of ensemble element j is","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"theta_n+1^(j) = theta_n^(j) - dfracDelta t_nJsum_k=1^Jlangle mathcalG(theta_n^(k)) - barmathcalG Gamma_y^-1(mathcalG(theta_n^(j)) - y) rangle theta_n^(k)","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"where the subscript n=1 dots I indicates the iteration, J is the number of elements in the ensemble and barmathcalG is the mean value of mathcalG(theta) across ensemble elements,","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"\\[ \\bar{\\mathcal{G}} = \\dfrac{1}{J}\\sum_{k=1}^J\\mathcal{G}(\\theta^{(k)}). \\]","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"The EKI algorithm is considered converged when the ensemble achieves sufficient consensus/collapse in parameter space. The final estimate bartheta^(I) is taken to be the ensemble mean at the final iteration,","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"bartheta^(I) = dfrac1Jsum_k=1^Jtheta^(I)","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"For typical applications, a near-optimal solution theta can be found after as few as 10 iterations of the algorithm. The obtained solution is optimal in the sense of the mean squared error loss, details can be found in Iglesias et al (2013). The algorithm performs better with larger ensembles. As a rule of thumb, the number of elements in the ensemble should be larger than 10p, although the optimal ensemble size may depend on the problem setting and the computational power available.","category":"page"},{"location":"ensemble_kalman_inversion/#Creating-the-EKI-Object","page":"Ensemble Kalman Inversion","title":"Creating the EKI Object","text":"","category":"section"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"An ensemble Kalman inversion object can be created using the EnsembleKalmanProcess constructor by specifying the Inversion() process type.","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"Creating an ensemble Kalman inversion object requires as arguments:","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"An initial parameter ensemble, Array{FT, 2} of size [p × J];\nThe mean value of the observed outputs, a vector of size [d];\nThe covariance of the observational noise, a matrix of size [d × d]\nThe Inversion() process type.","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"A typical initialization of the Inversion() process takes a user-defined prior, a summary of the observation statistics given by the mean y and covariance obs_noise_cov, and a desired number of elements in the ensemble,","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"using EnsembleKalmanProcesses.EnsembleKalmanProcessModule\nusing EnsembleKalmanProcesses.ParameterDistributionStorage\n\nJ = 50  # number of ensemble elements\ninitial_ensemble = construct_initial_ensemble(prior, J) # Initialize ensemble from prior\n\nekiobj = EnsembleKalmanProcess(initial_ensemble, y, obs_noise_cov, Inversion())","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"See the Prior distributions section to learn about the construction of priors in EnsembleKalmanProcesses.jl.","category":"page"},{"location":"ensemble_kalman_inversion/#Updating-the-Ensemble","page":"Ensemble Kalman Inversion","title":"Updating the Ensemble","text":"","category":"section"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"Once the ensemble Kalman inversion object ekiobj has been initialized, any number of updates can be performed using the inversion algorithm.","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"A call to the inversion algorithm can be performed with the update_ensemble! function. This function takes as arguments the ekiobj and the evaluations of the forward map at each element of the current ensemble. The update_ensemble! function then stores the new updated ensemble and the inputted forward map evaluations in ekiobj.","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"A typical use of the update_ensemble! function given the ensemble Kalman inversion object ekiobj and the forward map G is","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"N_iter = 20 # Number of steps of the algorithm\n\nfor i in 1:N_iter\n    params_i = get_u_final(ekiobj) # Get current ensemble\n    physical_params = transform_unconstrained_to_constrained(prior, params_i) # Transform parameters to physical space\n    g_ens = hcat([G(physical_params[:,i]) for i in 1:J]...) # Evaluate forward map\n    update_ensemble!(ekiobj, g_ens) # Update ensemble\nend","category":"page"},{"location":"ensemble_kalman_inversion/","page":"Ensemble Kalman Inversion","title":"Ensemble Kalman Inversion","text":"In the previous update, note that the parameters stored in ekiobj are given in the unconstrained Gaussian space where the EKI algorithm is performed. The map between this unconstrained space and the (possibly constrained) physical space of parameters is encoded in the prior object. The forward map G accepts as inputs the parameters in (possibly constrained) physical space, so it is necessary to apply transform_unconstrained_to_constrained before evaluations. See the Prior distributions section for more details on parameter transformations.","category":"page"},{"location":"API/ParameterDistribution/#ParameterDistribution","page":"ParameterDistribution","title":"ParameterDistribution","text":"","category":"section"},{"location":"API/ParameterDistribution/","page":"ParameterDistribution","title":"ParameterDistribution","text":"CurrentModule = EnsembleKalmanProcesses.ParameterDistributionStorage","category":"page"},{"location":"API/ParameterDistribution/","page":"ParameterDistribution","title":"ParameterDistribution","text":"Parameterized\nSamples\nConstraint\nno_constraint\nbounded_below\nbounded_above\nbounded\nlen\nn_samples\nParameterDistribution\nget_name\nget_dimensions\nget_n_samples\nget_all_constraints\nbatch\nget_distribution\nsample_distribution\nget_logpdf\nget_cov\nget_mean\ntransform_constrained_to_unconstrained\ntransform_unconstrained_to_constrained","category":"page"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.Parameterized","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.Parameterized","text":"struct Parameterized <: ParameterDistributionType\n\nA distribution constructed from a parametrized formula (e.g Julia Distributions.jl)\n\n\n\n\n\n","category":"type"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.Samples","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.Samples","text":"struct Samples{FT<:Real} <: ParameterDistributionType\n\nA distribution comprised of only samples, stored as columns of parameters\n\n\n\n\n\n","category":"type"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.Constraint","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.Constraint","text":"struct Constraint <: ConstraintType\n\nContains two functions to map between constrained and unconstrained spaces.\n\n\n\n\n\n","category":"type"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.no_constraint","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.no_constraint","text":"function no_constraint()\n\nConstructs a Constraint with no constraints, enforced by maps x -> x and x -> x.\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.bounded_below","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.bounded_below","text":"function bounded_below(lower_bound::FT) where {FT <: Real}\n\nConstructs a Constraint with provided lower bound, enforced by maps x -> log(x - lowerbound) and x -> exp(x) + lowerbound.\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.bounded_above","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.bounded_above","text":"function bounded_above(upper_bound::FT) where {FT <: Real}\n\nConstructs a Constraint with provided upper bound, enforced by maps x -> log(upperbound - x) and x -> upperbound - exp(x).\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.bounded","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.bounded","text":"function bounded(lower_bound::FT, upper_bound::FT) where {FT <: Real}\n\nConstructs a Constraint with provided upper and lower bounds, enforced by maps x -> log((x - lowerbound) / (upperbound - x)) and x -> (upperbound * exp(x) + lowerbound) / (exp(x) + 1)\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.len","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.len","text":"function len(c::Array{CType})\n\nThe number of constraints, each constraint has length 1.\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.n_samples","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.n_samples","text":"function n_samples(d::Samples)\n\nThe number of samples in the array\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.ParameterDistribution","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.ParameterDistribution","text":"struct ParameterDistribution\n\nStructure to hold a parameter distribution, always stored as an array of distributions\n\n\n\n\n\n","category":"type"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.get_name","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.get_name","text":"function get_name(pd::ParameterDistribution)\n\nReturns a list of ParameterDistribution names\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.get_dimensions","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.get_dimensions","text":"function get_dimensions(pd::ParameterDistribution)\n\nThe number of dimensions of the parameter space\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.get_n_samples","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.get_n_samples","text":"function get_n_samples(pd::ParameterDistribution)\n\nThe number of samples in a Samples distribution\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.get_all_constraints","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.get_all_constraints","text":"function get_all_constraints(pd::ParameterDistribution)\n\nreturns the (flattened) array of constraints of the parameter distribution\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.batch","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.batch","text":"function batch(pd:ParameterDistribution)\n\nReturns a list of contiguous [collect(1:i), collect(i+1:j),... ] used to split parameter arrays by distribution dimensions\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.get_distribution","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.get_distribution","text":"function get_distribution(pd::ParameterDistribution)\n\nReturns a Dict of ParameterDistribution distributions, with the parameter names as dictionary keys. For parameters represented by Samples, the samples are returned as a 2D (parameterdimension x nsamples) array\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.sample_distribution","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.sample_distribution","text":"function sample_distribution(pd::ParameterDistribution)\n\nDraws samples from the parameter distributions returns an array, with parameters as columns\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.get_logpdf","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.get_logpdf","text":"function logpdf(pd::ParameterDistribution, xarray::Array{<:Real,1})\n\nObtains the independent logpdfs of the parameter distributions at xarray (non-Samples Distributions only), and returns their sum.\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.get_cov","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.get_cov","text":"function get_cov(pd::ParameterDistribution)\n\nreturns a blocked covariance of the distributions\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.get_mean","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.get_mean","text":"get_mean(pd::Parameterized)\n\nreturns a mean of parameterized distribution\n\n\n\n\n\nget_mean(pd::Samples)\n\nreturns a mean of the samples\n\n\n\n\n\nfunction get_mean(pd::ParameterDistribution)\n\nreturns a mean of the distirbutions\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.transform_constrained_to_unconstrained","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.transform_constrained_to_unconstrained","text":"function transform_constrained_to_unconstrained(pd::ParameterDistribution, x::Array{<:Real})\n\nApply the transformation to map (possibly constrained) parameters xarray into the unconstrained space\n\n\n\n\n\n","category":"function"},{"location":"API/ParameterDistribution/#EnsembleKalmanProcesses.ParameterDistributionStorage.transform_unconstrained_to_constrained","page":"ParameterDistribution","title":"EnsembleKalmanProcesses.ParameterDistributionStorage.transform_unconstrained_to_constrained","text":"function transform_unconstrained_to_constrained(pd::ParameterDistribution, xarray::Array{Real})\n\nApply the transformation to map parameters xarray from the unconstrained space into (possibly constrained) space\n\n\n\n\n\n","category":"function"},{"location":"API/EnsembleKalmanProcesses/#EnsembleKalmanProcesses","page":"EnsembleKalmanProcesses","title":"EnsembleKalmanProcesses","text":"","category":"section"},{"location":"API/EnsembleKalmanProcesses/","page":"EnsembleKalmanProcesses","title":"EnsembleKalmanProcesses","text":"CurrentModule = EnsembleKalmanProcesses","category":"page"},{"location":"API/EnsembleKalmanProcesses/","page":"EnsembleKalmanProcesses","title":"EnsembleKalmanProcesses","text":"","category":"page"},{"location":"#EnsembleKalmanProcesses","page":"Home","title":"EnsembleKalmanProcesses","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"EnsembleKalmanProcesses.jl (EKP) is a library of derivative-free Bayesian optimization techniques based on the Ensemble Kalman Filters, a well known family of approximate filters used for data assimilation. Currently, the following methods are implemented in the library:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ensemble Kalman Inversion (EKI) - The traditional optimization technique based on the Ensemble Kalman Filter EnKF (Iglesias, Law, Stuart 2013),\nEnsemble Kalman Sampler (EKS) - also obtains a Gaussian Approximation of the posterior distribution, through a Monte Carlo integration (Garbuno-Inigo, Hoffmann, Li, Stuart 2020),\nUnscented Kalman Inversion (UKI) - also obtains a Gaussian Approximation of the posterior distribution, through a quadrature based integration approach (Huang Schneider Stuart 2020),\n[coming soon] Sparsity preserving Ensemble Kalman Inversion (SEKI) - Additionally adds approximate L^0 and L^1 penalization to the EKI (Schneider, Stuart, Wu 2020).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Module Purpose\nEnsembleKalmanProcesses.jl Collection of all tools\nEnsembleKalmanProcess.jl Implementations of EKI, EKS and UKI\nObservations.jl Structure to hold observational data\nParameterDistributions.jl Structures to hold prior and posterior distributions\nDataStorage.jl Structure to hold model parameters and outputs","category":"page"},{"location":"API/DataStorage/#DataStorage","page":"DataStorage","title":"DataStorage","text":"","category":"section"},{"location":"API/DataStorage/","page":"DataStorage","title":"DataStorage","text":"CurrentModule = EnsembleKalmanProcesses.DataStorage","category":"page"},{"location":"API/DataStorage/","page":"DataStorage","title":"DataStorage","text":"DataContainer\nPairedDataContainer\nsize","category":"page"},{"location":"API/DataStorage/#EnsembleKalmanProcesses.DataStorage.DataContainer","page":"DataStorage","title":"EnsembleKalmanProcesses.DataStorage.DataContainer","text":"struct DataContainer{FT <: Real}\n\nstruct to store data samples as columns in an array\n\n\n\n\n\n","category":"type"},{"location":"API/DataStorage/#EnsembleKalmanProcesses.DataStorage.PairedDataContainer","page":"DataStorage","title":"EnsembleKalmanProcesses.DataStorage.PairedDataContainer","text":"PairedDataContainer{FT <: Real}\n\nstores input - output pairs as data containers, there must be an equal number of inputs and outputs\n\n\n\n\n\n","category":"type"},{"location":"API/DataStorage/#Base.size","page":"DataStorage","title":"Base.size","text":"size(dc::DataContainer,idx::IT) where {IT <: Integer}\n\nreturns the size of the stored data (if idx provided, it returns the size along dimension idx) \n\n\n\n\n\nsize(pdc::PairedDataContainer,idx::IT) where {IT <: Integer}\n\nreturns the sizes of the inputs and ouputs along dimension idx (if provided)\n\n\n\n\n\n","category":"function"}]
}
